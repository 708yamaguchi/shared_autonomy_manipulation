Index: manifest.xml
===================================================================
--- manifest.xml	(revision 30593)
+++ manifest.xml	(working copy)
@@ -31,6 +31,10 @@
     <depend package="resource_retriever"/>
     <depend package="image_transport"/>
     <depend package="assimp"/>
+    
+    <depend package="interactive_rviz_msgs"/>
+    <depend package="visualization_msgs"/>
+    
     <export> 
         <cpp cflags="-I${prefix}/src/" lflags="-Wl,-rpath,${prefix}/lib -L${prefix}/lib -lrviz"/>
         <python path="${prefix}/lib/"/>
Index: src/rviz/tools/pose_tool_3d.h
===================================================================
--- src/rviz/tools/pose_tool_3d.h	(revision 0)
+++ src/rviz/tools/pose_tool_3d.h	(revision 0)
@@ -0,0 +1,93 @@
+/*
+ * 3d_pose_tool.h
+ *
+ *  Created on: 2010-06-15
+ *      Author: Hao Dang
+ */
+
+#ifndef RVIZ_POSE_TOOL_3D_H_
+#define RVIZ_POSE_TOOL_3D_H_
+
+#include "tool.h"
+
+#include <ros/ros.h>
+
+#include "selection/forwards.h"
+
+#include <tf/transform_broadcaster.h>
+#include <tf/transform_listener.h>
+
+#include <OGRE/OgrePlane.h>
+#include <OGRE/OgreSphere.h>
+#include <OGRE/OgreVector3.h>
+
+namespace Ogre
+{
+class Viewport;
+}
+
+namespace rviz
+{
+
+class VisualizationManager;
+
+class PoseTool3D : public Tool
+{
+public:
+	PoseTool3D( const std::string& name, char shortcut_key, VisualizationManager* manager );
+	virtual ~PoseTool3D();
+
+	virtual void activate();
+	virtual void deactivate();
+
+	virtual int processMouseEvent( ViewportMouseEvent& event );
+
+
+protected:
+	virtual void onPoseSet(double x, double y, double theta);
+
+	template <typename T>
+	Ogre::Vector3 get3DIntersectionFromMouseXY( Ogre::Viewport* viewport, int mouse_x, int mouse_y, T prototype);
+
+	Ogre::Plane getPlane(Ogre::Vector3 nromal, Ogre::Vector3 passing);
+
+	tf::StampedTransform getTransform(const std::string& reference, const std::string& target);
+
+	//determine whether the current selection contains any movable part, return a pionter to that one along with its type
+	bool getMovableSelected(void** movablePart, int& movableType);
+
+private:
+    tf::TransformListener listener_;
+    tf::TransformBroadcaster broadcaster_;
+    Ogre::Vector3 initialPosition_;
+    //this is only used for the rotation movement computation
+    tf::Transform initialTransform_;
+    ros::NodeHandle nh_;
+    ros::Publisher marker_pub_;
+    ros::Publisher pose_pub_;
+    ros::Publisher control_pub_;
+    enum Type
+    {
+    	Translation_Tool,
+    	Rotation_Tool,
+    	Broadcast_Tool
+    };
+    Type type_;
+    enum State
+    {
+    	Initialized,
+    	Position,
+    	Translation,
+    	Rotation
+    };
+    State state_;
+    void draw(Ogre::Vector3 position, Ogre::Vector3 orientation);
+    bool getDiffTransform(Ogre::Vector3 center, Ogre::Vector3 first, Ogre::Vector3 second, Ogre::Vector3& rot_axis, double& angle);
+
+    Ogre::Plane plane_;
+    Ogre::Sphere sphere_;
+};
+
+}// namespace rviz
+
+#endif /* RVIZ_POSE_TOOL_3D_H_ */
Index: src/rviz/tools/pose_tool_3d.cpp
===================================================================
--- src/rviz/tools/pose_tool_3d.cpp	(revision 0)
+++ src/rviz/tools/pose_tool_3d.cpp	(revision 0)
@@ -0,0 +1,398 @@
+/*
+ * 3d_pose_tool.cpp
+ *
+ *  Created on: 2010-06-15
+ *      Author: Hao Dang
+ */
+
+#include "pose_tool_3d.h"
+
+#include "visualization_manager.h"
+#include "viewport_mouse_event.h"
+#include "selection/selection_manager.h"
+#include "common.h"
+
+#include "robot/robot_link.h"
+#include "robot/robot.h"
+
+#include <OGRE/OgreCamera.h>
+#include <OGRE/OgreSceneNode.h>
+#include <OGRE/OgreViewport.h>
+#include <OGRE/OgreRay.h>
+#include <OgreMath.h>
+
+#include <visualization_msgs/Marker.h>
+#include <interactive_rviz_msgs/SelectionMessage.h>
+#include <interactive_rviz_msgs/ControlMessage.h>
+
+namespace rviz
+{
+
+PoseTool3D::PoseTool3D(const std::string& name, char shortcut_key, VisualizationManager* manager)
+: Tool( name, shortcut_key, manager ), state_(Initialized)
+{
+	if(std::strcmp(name.c_str(), "Translate") == 0)
+		type_ = Translation_Tool;
+	else if(std::strcmp(name.c_str(), "Rotate") == 0)
+		type_ = Rotation_Tool;
+	else if(std::strcmp(name.c_str(), "Broadcast") == 0)
+	{
+		type_ = Broadcast_Tool;
+		pose_pub_ = nh_.advertise<interactive_rviz_msgs::SelectionMessage>("sTopic",1);
+	}
+	else
+		ROS_INFO("UNKNOWN TYPE");
+	marker_pub_ = nh_.advertise<visualization_msgs::Marker>("debug_marker", 0);
+	control_pub_ = nh_.advertise<interactive_rviz_msgs::ControlMessage>("cTopic", 1);
+}
+
+PoseTool3D::~PoseTool3D()
+{
+
+}
+
+void PoseTool3D::activate()
+{
+	if(type_ == Broadcast_Tool)
+	{
+		int type;
+		void * selectedPart;
+		//check if it is movable
+		if(!getMovableSelected(&selectedPart, type))
+			return;
+		RobotLink* link;
+		if(type == SelectionHandler::Link)
+			link = (RobotLink*) selectedPart;
+		else{
+			ROS_INFO("Unhandled type of selected part");
+			return;
+		}
+
+
+		interactive_rviz_msgs::SelectionMessage msg;
+		//get where the link is currently at in the world coordinate system
+		transformStampedTFToMsg(getTransform("/virtual_gripper_origin", link->getName()),
+				msg.transform);
+
+		msg.type = interactive_rviz_msgs::SelectionMessage::GRASP_POSE_SELECTION;
+//		msg.pose.position.x = transform.getOrigin().getX();
+//		msg.pose.position.y = transform.getOrigin().getY();
+//		msg.pose.position.z = transform.getOrigin().getZ();
+//		msg.pose.orientation.w = transform.getRotation().getW();
+//		msg.pose.orientation.x = transform.getRotation().getX();
+//		msg.pose.orientation.y = transform.getRotation().getY();
+//		msg.pose.orientation.z = transform.getRotation().getZ();
+		pose_pub_.publish(msg);
+	}
+
+}
+
+void PoseTool3D::deactivate()
+{
+
+}
+
+void PoseTool3D::onPoseSet(double x, double y, double theta)
+{
+
+}
+
+int PoseTool3D::processMouseEvent(rviz::ViewportMouseEvent & event)
+{
+	int type;
+	void * selectedPart;
+	//check if it is movable
+	if(!getMovableSelected(&selectedPart, type))
+		return -1;
+	RobotLink* link;
+	if(type == SelectionHandler::Link)
+		link = (RobotLink*) selectedPart;
+	else{
+		ROS_INFO("Unhandled type of selected part");
+		return -1;
+	}
+
+	//get where the link is currently at in the world coordinate system
+	tf::Transform transform;
+	transform = static_cast<tf::Transform>(getTransform("/virtual_gripper_origin", link->getName()));
+
+	//handles the mouse event
+	//every movement starts with the left button pressed down
+	if ( event.event.LeftDown() )
+	{
+		ROS_ASSERT( state_ == Initialized );
+		//first work in ogre space
+		Ogre::Vector3 passing(transform.getOrigin().x(), transform.getOrigin().y(), transform.getOrigin().z());
+		//change to ogre space
+		robotToOgre(passing);
+		if(type_ == Translation_Tool){
+			plane_ = getPlane(event.viewport->getCamera()->getDirection(), passing);
+			initialPosition_ = get3DIntersectionFromMouseXY( event.viewport, event.event.GetX(), event.event.GetY(), plane_ );
+		}
+		else if(type_ == Rotation_Tool){
+			sphere_ = Ogre::Sphere(passing, 0.1);
+			initialPosition_ = get3DIntersectionFromMouseXY( event.viewport, event.event.GetX(), event.event.GetY(), sphere_ );
+		}
+		initialTransform_ = transform;
+		state_ =Position;
+	}
+	else if ( event.event.Dragging() )
+	{
+		if(state_ == Position && type_ == Translation_Tool)
+		{
+			//offset computed in ogre space
+			Ogre::Vector3 cur_pos = get3DIntersectionFromMouseXY( event.viewport, event.event.GetX(), event.event.GetY(), plane_ );
+			Ogre::Vector3 off(cur_pos.x - initialPosition_.x, cur_pos.y - initialPosition_.y, cur_pos.z - initialPosition_.z);
+			//change the offset back to robot space
+			ogreToRobot(off);
+			transform.setOrigin(tf::Vector3(initialTransform_.getOrigin().x() + off.x, initialTransform_.getOrigin().y() + off.y, initialTransform_.getOrigin().z() + off.z));
+		}
+		else if(state_ == Position && type_ == Rotation_Tool)
+		{
+			//draw reference dragger ball in robot space
+			Ogre::Vector3 center(transform.getOrigin().x(), transform.getOrigin().y(), transform.getOrigin().z());
+			draw(center, Ogre::Vector3::ZERO);
+			//compute the intersection in ogre space
+			Ogre::Vector3 cur_pos = get3DIntersectionFromMouseXY( event.viewport, event.event.GetX(), event.event.GetY(), sphere_ );
+
+			double angle;
+			Ogre::Vector3 rot_axis;
+			//compute the rotation in ogre space
+			getDiffTransform(sphere_.getCenter(), initialPosition_, cur_pos, rot_axis, angle);
+
+			//go back to robot space, the angle will keep the same
+			ogreToRobot(rot_axis);
+			//std::cout << "robot rot_axis is: " << rot_axis.x << " " << rot_axis.y << " " << rot_axis.z << " angle computed is: " << angle << std::endl;
+
+			//synthesise the rotation
+			tf::Transform off = tf::Transform::getIdentity();
+			tf::Quaternion off_rot(tf::Vector3(rot_axis.x, rot_axis.y, rot_axis.z), angle);
+			off.setRotation(off_rot);
+
+			//apply the difference in the robot space
+			tf::Transform mt, mr;
+			mt = mr = tf::Transform::getIdentity();
+			mt.setOrigin(initialTransform_.getOrigin());
+			mr.setRotation(initialTransform_.getRotation());
+			transform = off * mr;
+
+			transform = mt * transform;
+
+			//    		std::cout << "new translation is:" << transform.getOrigin().x() << " " << transform.getOrigin().y() << " " << transform.getOrigin().z() << std::endl;
+			//    		std::cout << "new orientation is:" << transform.getRotation().x() << " " << transform.getOrigin().y() << " " << transform.getOrigin().z() << std::endl;
+			//record the current orientation
+			//    		initialPosition_ = cur_pos;
+		}
+	}
+	else if ( event.event.LeftUp() )
+	{
+		state_ = Initialized;
+	}
+
+
+	//send tf transform command to udpate the robot in RVIZ
+	broadcaster_.sendTransform(tf::StampedTransform(transform, ros::Time::now(), "/virtual_gripper_origin", link->getName().c_str()));
+
+	interactive_rviz_msgs::ControlMessage cm;
+//	geometry_msgs::TransformStamped ts;
+//	tf::transformStampedTFToMsg(tf::StampedTransform(transform, ros::Time::now(), "/virtual_gripper_origin", link->getName().c_str()),
+//			ts);
+//	cm.transform = ts;
+	cm.moved = 1;
+	control_pub_.publish(cm);
+
+	return 0;
+}
+
+//compute the rotation from first to second position with respect to center position
+bool PoseTool3D::getDiffTransform(Ogre::Vector3 center, Ogre::Vector3 first, Ogre::Vector3 second, Ogre::Vector3& rot_axis, double& angle)
+{
+	//	tf::Transform t = tf::Transform::getIdentity();
+	Ogre::Vector3 v1, v2, ref_axis; // rot_axis is the rotational axis, ref_axis is just the only perpendicular to v1 and with in v1-v2 plane
+
+	//	std::cout << "first: " << first.x << " " << first.y << " " << first.z << std::endl;
+	//	std::cout << "second: " << second.x << " " << second.y << " " << second.z << std::endl;
+	//	std::cout << "center: " << center.x << " " << center.y << " " << center.z << std::endl;
+
+	//compute the rotation axis
+	//get the two directional vectors
+	v1 = first - center;
+	v2 = second - center;
+	//normalise them
+	v1.normalise();
+	v2.normalise();
+	//cross product and compute the rotation axis
+	rot_axis = v1.crossProduct(v2);
+	rot_axis.normalise();
+
+	//compute the angle of the rotation
+	ref_axis = rot_axis.crossProduct(v1);
+	ref_axis.normalise();
+	double x,y;
+	x = v2.dotProduct(v1);
+	y = v2.dotProduct(ref_axis);
+	angle = atan2(y,x);
+
+	//	std::cout << "ogre rot_axis is: " << rot_axis.x << " " << rot_axis.y << " " << rot_axis.z << " angle computed is: " << angle << std::endl;
+
+	return true;
+}
+
+Ogre::Plane PoseTool3D::getPlane(Ogre::Vector3 normal, Ogre::Vector3 passing)
+{
+	Ogre::Plane plane( normal.x,
+			normal.y,
+			normal.z,
+			- normal.x * passing.x - normal.y * passing.y - normal.z * passing.z);
+	return  plane;
+}
+
+//all the computation is in ogre space
+template <typename T>
+Ogre::Vector3 PoseTool3D::get3DIntersectionFromMouseXY( Ogre::Viewport* viewport, int mouse_x, int mouse_y, T prototype)
+{
+	int width = viewport->getActualWidth();
+	int height = viewport->getActualHeight();
+
+	Ogre::Ray mouse_ray = viewport->getCamera()->getCameraToViewportRay( (float)mouse_x / (float)width, (float)mouse_y / (float)height );
+
+	std::pair<bool, Ogre::Real> intersection = mouse_ray.intersects( prototype );
+	if ( !intersection.first )
+	{
+		ROS_INFO("NO INTERSECTION");
+		return Ogre::Vector3::ZERO;
+	}
+	//	std::cout << "intersected at: " << intersection.second << std::endl;
+	return mouse_ray.getPoint( intersection.second );
+}
+
+//this computes the transform in robot space
+tf::StampedTransform PoseTool3D::getTransform(const std::string& reference, const std::string& target)
+{
+	//get where the link is currently at in the world coordinate system
+	tf::StampedTransform transform;
+
+	try{
+		//    	ROS_INFO("TRY BLOCK");
+		listener_.lookupTransform(reference.c_str(), target.c_str(),
+				ros::Time(0), transform);
+	}
+	catch (tf::TransformException ex){
+		ROS_ERROR("TRY FAILED: PROBLEM: %s",ex.what());
+	}
+
+	return transform;
+}
+
+bool PoseTool3D::getMovableSelected(void** movablePart, int& movableType)
+{
+	SelectionManager* sel_manager = manager_->getSelectionManager();
+
+	//make sure we have selected and only selected one link
+	if( sel_manager->getSelection().size() == 0 )
+		ROS_INFO("Nothing selected");
+	if( sel_manager->getSelection().size() > 1 ){
+		ROS_INFO("Do not support multiple selection right now, try selecting only the base of the robot to move it");
+		return false;
+	}
+
+	//get the first selected as well as the only selected part
+	M_Picked::const_iterator it = sel_manager->getSelection().begin();
+	const Picked& picked = it->second;
+
+	SelectionHandlerPtr handler = sel_manager->getHandler(picked.handle);
+	if(!handler){
+		ROS_INFO("Nothing selected");
+		return false;
+	}
+	if(handler->getSelectionType() != rviz::SelectionHandler::Link){
+		ROS_INFO("Not a link selected");
+		return false;
+	}
+	//	RobotLink* link = (RobotLink*) (handler->getCoreObject());
+	*movablePart = handler->getCoreObject();
+	movableType = handler->getSelectionType();
+
+	return true;
+}
+
+//work in rviz world, not ogre world
+void PoseTool3D::draw(Ogre::Vector3 position, Ogre::Vector3 orientation)
+{
+	double s = 0.2;
+	double a = 0.5;
+	visualization_msgs::Marker marker;
+	marker.header.frame_id = "/virtual_gripper_origin";
+	marker.header.stamp = ros::Time::now();
+	marker.ns = "debug_tools";
+	marker.id = 0;
+	marker.type = visualization_msgs::Marker::SPHERE;
+	marker.action = visualization_msgs::Marker::ADD;
+	marker.pose.position.x = position.x;
+	marker.pose.position.y = position.y;
+	marker.pose.position.z = position.z;
+	marker.pose.orientation.x = 0.0;
+	marker.pose.orientation.y = 0.0;
+	marker.pose.orientation.z = 0.0;
+	marker.pose.orientation.w = 1.0;
+	marker.scale.x = s;
+	marker.scale.y = s;
+	marker.scale.z = s;
+	marker.color.r = 0.0f;
+	marker.color.g = 1.0f;
+	marker.color.b = 0.0f;
+	marker.color.a = a;
+	marker.lifetime = ros::Duration();
+	marker_pub_.publish(marker);
+
+	marker.header.frame_id = "/virtual_gripper_origin";
+	marker.header.stamp = ros::Time::now();
+	marker.ns = "debug_tools";
+	marker.id = 1;
+	marker.type = visualization_msgs::Marker::SPHERE;
+	marker.action = visualization_msgs::Marker::ADD;
+	marker.pose.position.x = position.x + 0.1*orientation.x;
+	marker.pose.position.y = position.y + 0.1*orientation.y;
+	marker.pose.position.z = position.z + 0.1*orientation.z;
+	marker.pose.orientation.x = 0.0;
+	marker.pose.orientation.y = 0.0;
+	marker.pose.orientation.z = 0.0;
+	marker.pose.orientation.w = 1.0;
+	marker.scale.x = s;
+	marker.scale.y = s;
+	marker.scale.z = s;
+	marker.color.r = 0.0f;
+	marker.color.g = 1.0f;
+	marker.color.b = 0.0f;
+	marker.color.a = a;
+	marker.lifetime = ros::Duration();
+	marker_pub_.publish(marker);
+
+	marker.header.frame_id = "/virtual_gripper_origin";
+	marker.header.stamp = ros::Time::now();
+	marker.ns = "debug_tools";
+	marker.id = 2;
+	marker.type = visualization_msgs::Marker::SPHERE;
+	marker.action = visualization_msgs::Marker::ADD;
+	marker.pose.position.x = position.x + 0.2*orientation.x;
+	marker.pose.position.y = position.y + 0.2*orientation.y;
+	marker.pose.position.z = position.z + 0.2*orientation.z;
+	marker.pose.orientation.x = 0.0;
+	marker.pose.orientation.y = 0.0;
+	marker.pose.orientation.z = 0.0;
+	marker.pose.orientation.w = 1.0;
+	marker.scale.x = s;
+	marker.scale.y = s;
+	marker.scale.z = s;
+	marker.color.r = 0.0f;
+	marker.color.g = 1.0f;
+	marker.color.b = 0.0f;
+	marker.color.a = a;
+	marker.lifetime = ros::Duration();
+	marker_pub_.publish(marker);
+}
+
+
+}//rviz
+
+
Index: src/rviz/robot/robot_link.cpp
===================================================================
--- src/rviz/robot/robot_link.cpp	(revision 30593)
+++ src/rviz/robot/robot_link.cpp	(working copy)
@@ -72,6 +72,10 @@
 
   virtual void createProperties(const Picked& obj, PropertyManager* property_manager);
 
+  //for addons of user interface
+  virtual SelectionType getSelectionType() {return Link;}
+  virtual void * getCoreObject(){return (void*)link_;}
+
 private:
   RobotLink* link_;
 };
Index: src/rviz/rviz_communicator.cpp
===================================================================
--- src/rviz/rviz_communicator.cpp	(revision 0)
+++ src/rviz/rviz_communicator.cpp	(revision 0)
@@ -0,0 +1,64 @@
+/*
+ *  rviz_communicator.cpp
+ *
+ *  Created on: 2010-06-01
+ *      Author: Hao Dang
+ */
+
+#include "rviz_communicator.h"
+#include "visualization_manager.h"
+#include "selection/selection_manager.h"
+#include "selection/forwards.h"
+
+//#include <rviz/SelectionMessage.h>
+#include <interactive_rviz_msgs/SelectionMessage.h>
+
+#include <ros/console.h>
+
+#include <boost/bind.hpp>
+
+namespace rviz
+{
+
+RvizCommunicator::RvizCommunicator() : first_selection_ (NULL)
+{
+
+}
+
+RvizCommunicator::~RvizCommunicator()
+{
+
+}
+
+void RvizCommunicator::initialize(VisualizationManager* manager)
+{
+	ROS_INFO("COMMUNICATOR INITIALIZED");
+	manager_ = manager;
+	manager_->getSelectionManager()->getSelectionAddedSignal().connect(
+					boost::bind( &RvizCommunicator::onSelectionAdded, this, _1 ) );
+//	pub_ = nh_.advertise<rviz::SelectionMessage>("sTopic", 1);
+	pub_ = nh_.advertise<interactive_rviz_msgs::SelectionMessage>("sTopic", 1);
+
+}
+
+void RvizCommunicator::onSelectionAdded(const SelectionAddedArgs& args)
+{
+//	ROS_INFO("signal emitted and onSelectionAdded triggered");
+
+	SelectionManager* sel_manager = manager_->getSelectionManager();
+
+	M_Picked::const_iterator it = args.added_.begin();
+	M_Picked::const_iterator end = args.added_.end();
+
+	first_selection_ = &(it->second);
+
+	for (; it != end; ++it)
+	{
+		const Picked& picked = it->second;
+		SelectionHandlerPtr handler = sel_manager->getHandler(picked.handle);
+		ROS_ASSERT(handler);
+		handler->publishToTopic(picked, &pub_);
+	}
+}
+
+} // namespace rviz
Index: src/rviz/visualization_frame.h
===================================================================
--- src/rviz/visualization_frame.h	(revision 30593)
+++ src/rviz/visualization_frame.h	(working copy)
@@ -57,6 +57,7 @@
 class VisualizationManager;
 class Tool;
 class SplashScreen;
+class RvizCommunicator;
 
 class VisualizationFrame : public wxFrame, public WindowManagerInterface
 {
@@ -108,6 +109,7 @@
   TimePanel* time_panel_;
   SelectionPanel* selection_panel_;
   ToolPropertiesPanel* tool_properties_panel_;
+  RvizCommunicator* rviz_communicator_;
 
   boost::shared_ptr<wxConfigBase> general_config_;
   boost::shared_ptr<wxConfigBase> display_config_;
Index: src/rviz/visualization_frame.cpp
===================================================================
--- src/rviz/visualization_frame.cpp	(revision 30593)
+++ src/rviz/visualization_frame.cpp	(working copy)
@@ -40,6 +40,7 @@
 #include "splash_screen.h"
 #include "loading_dialog.h"
 #include "common.h"
+#include "rviz_communicator.h"
 
 #include <ros/package.h>
 #include <ros/console.h>
@@ -174,6 +175,7 @@
   time_panel_ = new TimePanel( this );
   selection_panel_ = new SelectionPanel( this );
   tool_properties_panel_ = new ToolPropertiesPanel(this);
+  rviz_communicator_ = new RvizCommunicator ();
 
   splash_->setState("Initializing OGRE resources");
   ogre_tools::V_string paths;
@@ -206,6 +208,7 @@
   time_panel_->initialize(manager_);
   selection_panel_->initialize(manager_);
   tool_properties_panel_->initialize(manager_);
+  rviz_communicator_->initialize(manager_);
 
   manager_->getToolAddedSignal().connect( boost::bind( &VisualizationFrame::onToolAdded, this, _1 ) );
   manager_->getToolChangedSignal().connect( boost::bind( &VisualizationFrame::onToolChanged, this, _1 ) );
Index: src/rviz/rviz_communicator.h
===================================================================
--- src/rviz/rviz_communicator.h	(revision 0)
+++ src/rviz/rviz_communicator.h	(revision 0)
@@ -0,0 +1,52 @@
+/*
+ *  rviz_communicator.h
+ *
+ *  Created on: 2010-06-01
+ *      Author: Hao Dang
+ */
+
+/*
+ * This class should keep track of what is being selected and publish necessary messages s.t. subscribers could know what the user's input is.
+ * For the initial version, this should track the markers, and return the marker's ID which should be unique
+ * Also, this should also track the point cloud, and return the selected points for post processing such as model fitting, etc.
+ */
+
+#ifndef RIVZ_COMMUNICATOR_H
+#define RIVZ_COMMUNICATOR_H
+
+
+#include <ros/ros.h>
+
+// this is ugly, I mean my code
+#include "default_plugin/markers/marker_selection_handler.h"
+#include <boost/shared_ptr.hpp>
+
+#include <selection/forwards.h>
+
+namespace rviz
+{
+class VisualizationManager;
+class SelectionAddedArgs;
+typedef boost::shared_ptr<MarkerSelectionHandler> MarkerSelectionHandlerPointer;
+
+
+class RvizCommunicator
+{
+private:
+	VisualizationManager* manager_;
+	  ros::NodeHandle nh_;
+	  ros::Publisher pub_;
+	  const Picked* first_selection_;
+
+protected:
+	void onSelectionAdded(const SelectionAddedArgs& args);
+
+public:
+	RvizCommunicator();
+	~RvizCommunicator();
+	void initialize(VisualizationManager* manager);
+};
+
+} // namespace rviz
+
+#endif // RIVZ_COMMUNICATOR_H
Index: src/rviz/visualization_manager.cpp
===================================================================
--- src/rviz/visualization_manager.cpp	(revision 30593)
+++ src/rviz/visualization_manager.cpp	(working copy)
@@ -52,6 +52,7 @@
 #include "tools/goal_tool.h"
 #include "tools/initial_pose_tool.h"
 #include "tools/selection_tool.h"
+#include "tools/pose_tool_3d.h"
 
 #include <ogre_tools/wx_ogre_render_window.h>
 
@@ -220,6 +221,11 @@
   createTool< GoalTool >( "2D Nav Goal", 'g' );
   createTool< InitialPoseTool >( "2D Pose Estimate", 'p' );
 
+  //for user interface
+  createTool< PoseTool3D >( "Translate", 't' );
+  createTool< PoseTool3D >( "Rotate", 'r' );
+  createTool< PoseTool3D >( "Broadcast", 'b' );
+
   selection_manager_->initialize();
 
   last_update_ros_time_ = ros::Time::now();
Index: src/rviz/CMakeLists.txt
===================================================================
--- src/rviz/CMakeLists.txt	(revision 30593)
+++ src/rviz/CMakeLists.txt	(working copy)
@@ -54,6 +54,7 @@
                                     tools/goal_tool.cpp
                                     tools/initial_pose_tool.cpp
                                     tools/selection_tool.cpp
+                                    tools/pose_tool_3d.cpp
                                     mesh_loader.cpp
                                     splash_screen.cpp
                                     loading_dialog.cpp
@@ -83,7 +84,8 @@
                                     robot/robot_link.cpp
                                     robot/robot.cpp
                                     selection/selection_manager.cpp
-                                    generated/rviz_generated.cpp)
+                                    generated/rviz_generated.cpp
+                                    rviz_communicator.cpp)
 target_link_libraries(${PROJECT_NAME} ${wxWidgets_LIBRARIES} ${OGRE_LIBRARIES})
 rosbuild_link_boost(${PROJECT_NAME} thread signals filesystem system program_options)
 
Index: src/rviz/selection/selection_manager.cpp
===================================================================
--- src/rviz/selection/selection_manager.cpp	(revision 30593)
+++ src/rviz/selection/selection_manager.cpp	(working copy)
@@ -1048,4 +1048,9 @@
   }
 }
 
+void SelectionHandler::publishToTopic(const Picked& obj, ros::Publisher* pub)
+{
+	ROS_INFO("publishToTopic method undefined");
+}
+
 } // namespace rviz
Index: src/rviz/selection/selection_manager.h
===================================================================
--- src/rviz/selection/selection_manager.h	(revision 30593)
+++ src/rviz/selection/selection_manager.h	(working copy)
@@ -55,6 +55,11 @@
 class Object;
 }
 
+namespace ros
+{
+class Publisher;
+}
+
 namespace Ogre
 {
 class SceneManager;
@@ -98,6 +103,16 @@
 class SelectionHandler
 {
 public:
+	enum SelectionType
+	{
+		Undefined,
+		Marker,
+		Points,
+		Link,
+		Frame,
+		PoseDisplay
+	};
+
   typedef std::vector<PropertyBaseWPtr> V_Property;
 
   SelectionHandler();
@@ -126,6 +141,11 @@
   virtual void onSelect(const Picked& obj);
   virtual void onDeselect(const Picked& obj);
 
+  //addons for user interface
+  virtual void publishToTopic(const Picked& obj, ros::Publisher* pub);
+  virtual SelectionType getSelectionType() {return Undefined;}
+  virtual void * getCoreObject() {return NULL;}
+
 protected:
   void createBox(const std::pair<CollObjectHandle, uint64_t>& handles, const Ogre::AxisAlignedBox& aabb, const std::string& material_name);
   void destroyBox(const std::pair<CollObjectHandle, uint64_t>& handles);
Index: src/rviz/default_plugin/point_cloud_base.cpp
===================================================================
--- src/rviz/default_plugin/point_cloud_base.cpp	(revision 30593)
+++ src/rviz/default_plugin/point_cloud_base.cpp	(working copy)
@@ -50,6 +50,14 @@
 #include <OGRE/OgreSceneManager.h>
 #include <OGRE/OgreWireBoundingBox.h>
 
+#include <interactive_rviz_msgs/SelectionMessage.h>
+#include <geometry_msgs/Point32.h>
+
+namespace ros
+{
+class Publisher;
+}
+
 namespace rviz
 {
 
@@ -86,6 +94,8 @@
 
   virtual void getAABBs(const Picked& obj, V_AABB& aabbs);
 
+  virtual void publishToTopic(const Picked& obj, ros::Publisher* pub);
+
 private:
   void getCloudAndLocalIndexByGlobalIndex(int global_index, PointCloudBase::CloudInfoPtr& cloud_out, int& index_out);
 
@@ -299,6 +309,7 @@
     sensor_msgs::PointCloud2Ptr message = cloud->message_;
 
     Ogre::Vector3 pos = cloud->transform_ * pointFromCloud(message, index);
+//    std::cout << "point is: " << pos.x << " " << pos.y << " " << pos.z << std::endl;
 
     float size = 0.002;
     if (display_->style_ != PointCloudBase::Points)
@@ -324,6 +335,52 @@
   }
 }
 
+void PointCloudSelectionHandler::publishToTopic(const Picked& obj, ros::Publisher* pub)
+{
+//	rviz::SelectionMessage msg;
+	interactive_rviz_msgs::SelectionMessage msg;
+	int numP = 0;
+
+	  typedef std::set<int> S_int;
+	  S_int indices;
+	  {
+	    S_uint64::const_iterator it = obj.extra_handles.begin();
+	    S_uint64::const_iterator end = obj.extra_handles.end();
+	    for (; it != end; ++it)
+	    {
+	      uint64_t handle = *it;
+	      indices.insert((handle & 0xffffffff) - 1);
+	    }
+	  }
+
+	  {
+	    S_int::iterator it = indices.begin();
+	    S_int::iterator end = indices.end();
+	    for (; it != end; ++it)
+	    {
+	      int global_index = *it;
+	      int index = 0;
+	      PointCloudBase::CloudInfoPtr cloud;
+
+	      getCloudAndLocalIndexByGlobalIndex(global_index, cloud, index);
+
+	      if (!cloud->message_)
+	      {
+	        continue;
+	      }
+	      Ogre::Vector3 pos = cloud->transform_ * pointFromCloud(cloud->message_, index);
+	      geometry_msgs::Point32 point;
+	      point.x = pos.x;
+	      point.y = pos.y;
+	      point.z = pos.z;
+	      msg.points.push_back(point);
+	      numP++;
+	    }
+	  }
+	  msg.numPoints = numP;
+	  pub->publish(msg);
+}
+
 PointCloudBase::CloudInfo::CloudInfo(VisualizationManager* manager)
 : time_(0.0f)
 , transform_(Ogre::Matrix4::ZERO)
Index: src/rviz/default_plugin/markers/marker_selection_handler.cpp
===================================================================
--- src/rviz/default_plugin/markers/marker_selection_handler.cpp	(revision 30593)
+++ src/rviz/default_plugin/markers/marker_selection_handler.cpp	(working copy)
@@ -38,6 +38,8 @@
 
 #include <boost/bind.hpp>
 
+#include <interactive_rviz_msgs/SelectionMessage.h>
+
 namespace rviz
 {
 
@@ -71,4 +73,14 @@
   properties_.push_back(property_manager->createProperty<QuaternionProperty>("Orientation", prefix.str(), boost::bind(&MarkerSelectionHandler::getOrientation, this), QuaternionProperty::Setter(), cat));
 }
 
+void MarkerSelectionHandler::publishToTopic(const Picked& obj, ros::Publisher* pub)
+{
+//	rviz::SelectionMessage msg;
+	interactive_rviz_msgs::SelectionMessage msg;
+	msg.type = interactive_rviz_msgs::SelectionMessage::MARKER_SELECTION;
+	msg.markerNameSpace = id_.first;
+	msg.markerID = id_.second;
+	pub->publish(msg);
 }
+
+}
Index: src/rviz/default_plugin/markers/marker_selection_handler.h
===================================================================
--- src/rviz/default_plugin/markers/marker_selection_handler.h	(revision 30593)
+++ src/rviz/default_plugin/markers/marker_selection_handler.h	(working copy)
@@ -33,6 +33,11 @@
 #include "rviz/selection/forwards.h"
 #include "rviz/selection/selection_manager.h"
 
+namespace ros
+{
+class Publisher;
+}
+
 namespace rviz
 {
 class MarkerBase;
@@ -55,7 +60,7 @@
   Ogre::Quaternion getOrientation();
 
   virtual void createProperties(const Picked& obj, PropertyManager* property_manager);
-
+  virtual void publishToTopic(const Picked& obj, ros::Publisher* pub);
 private:
   const MarkerBase* marker_;
   MarkerID id_;
